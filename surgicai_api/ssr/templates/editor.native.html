{% extends "base.html" %}

{% block title %}Editor - OperativeAI{% endblock %}

{% block head %}
<style>
  .editor-container {
    max-width: 1200px;
    margin: 0 auto;
    background: white;
    border-radius: 12px;
    box-shadow: 0 4px 6px rgba(0,0,0,0.1);
    overflow: hidden;
  }
  
  .editor-toolbar {
    background: linear-gradient(135deg, var(--primary-color) 0%, var(--secondary-color) 100%);
    color: white;
    padding: 1.5rem 2rem;
    display: flex;
    justify-content: space-between;
    align-items: center;
    flex-wrap: wrap;
    gap: 1rem;
  }
  
  .editor-actions {
    background: white;
    padding: 1rem 2rem;
    border-bottom: 1px solid #e9ecef;
    display: flex;
    justify-content: space-between;
    align-items: center;
    gap: 1rem;
  }
  
  .toolbar-group {
    display: flex;
    gap: 0.5rem;
    align-items: center;
  }
  
  .toolbar-separator {
    width: 1px;
    height: 24px;
    background: #dee2e6;
    margin: 0 0.5rem;
  }
  
  .action-buttons {
    display: flex;
    gap: 1rem;
    margin-left: auto;
  }
  
  .editor-main {
    padding: 0;
  }
  
  .editor-content {
    width: 100%;
    min-height: 500px;
    border: none;
    outline: none;
    padding: 2rem;
    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    font-size: 12pt;
    line-height: 1.6;
    background: white;
    white-space: pre-wrap;
    word-wrap: break-word;
    color: var(--dark-text);
  }
  
  .editor-content:focus {
    border: none;
    outline: none;
    box-shadow: none;
  }
  
  .field-inline {
    display: inline-block;
    position: relative;
    background: #fefce8;
    border: 1px solid #eab308;
    border-radius: 4px;
    padding: 2px 6px 4px 6px;
    margin: 0 2px;
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
    cursor: default;
    vertical-align: baseline;
    line-height: 1.2;
    isolation: isolate;
    min-width: 20px;
    outline: none;
    transition: background-color 0.2s ease, border-color 0.2s ease;
  }
  
  .field-inline:focus {
    background: #fef3c7;
    border-color: #d97706;
    box-shadow: 0 0 0 2px rgba(234, 179, 8, 0.1);
  }
  
  .field-inline:hover {
    background: #fef3c7;
    border-color: #d97706;
  }
  
  .field-inline:empty::before {
    content: attr(data-placeholder);
    color: #92400e;
    font-style: italic;
    font-size: 11px;
  }
  
  .aifield-inline {
    display: inline-block;
    position: relative;
    background: #dbeafe;
    border: 1px solid #3b82f6;
    border-radius: 4px;
    padding: 2px 6px 4px 6px;
    margin: 0 2px;
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
    cursor: default;
    vertical-align: baseline;
    line-height: 1.2;
    isolation: isolate;
    min-width: 20px;
    outline: none;
    transition: background-color 0.2s ease, border-color 0.2s ease;
  }
  
  .aifield-inline:focus {
    background: #bfdbfe;
    border-color: #2563eb;
    box-shadow: 0 0 0 2px rgba(59, 130, 246, 0.1);
  }
  
  .aifield-inline:hover {
    background: #bfdbfe;
    border-color: #2563eb;
  }
  
  .aifield-inline:empty::before {
    content: attr(data-placeholder);
    color: #1e40af;
    font-style: italic;
    font-size: 12px;
  }
  
  .editor-status {
    display: flex;
    align-items: center;
    gap: 1rem;
    font-size: 0.9rem;
    color: white;
  }
  
  .status-indicator {
    padding: 0.25rem 0.75rem;
    border-radius: 20px;
    font-size: 0.8rem;
    font-weight: 500;
    background: rgba(255,255,255,0.2);
    backdrop-filter: blur(10px);
  }
  
  .status-badge {
    padding: 0.25rem 0.75rem;
    border-radius: 20px;
    font-size: 0.8rem;
    font-weight: 500;
    background: rgba(255,255,255,0.2);
    backdrop-filter: blur(10px);
    display: flex;
    align-items: center;
    gap: 0.25rem;
  }
  
  .status-badge.draft {
    background: rgba(108, 117, 125, 0.2);
    color: rgba(255, 255, 255, 0.9);
  }
  
  .status-badge.optimized {
    background: rgba(40, 167, 69, 0.2);
    color: rgba(255, 255, 255, 0.9);
  }
  
  .status-badge.signed {
    background: rgba(0, 123, 255, 0.2);
    color: rgba(255, 255, 255, 0.9);
  }
  
  .unsaved-indicator {
    padding: 0.25rem 0.75rem;
    border-radius: 20px;
    font-size: 0.8rem;
    font-weight: 500;
    background: rgba(255, 193, 7, 0.2);
    color: rgba(255, 193, 7, 0.9);
    backdrop-filter: blur(10px);
    animation: pulse 2s infinite;
  }
  
  @keyframes pulse {
    0% { opacity: 0.6; }
    50% { opacity: 1; }
    100% { opacity: 0.6; }
  }
  
  .editor-title {
    font-size: 1.5rem;
    font-weight: 600;
    margin: 0;
    flex: 1;
    color: white;
  }
  
  .editor-loading-overlay {
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background: rgba(255, 255, 255, 0.9);
    display: flex;
    justify-content: center;
    align-items: center;
    z-index: 1000;
  }
  
  .loading-content {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 1rem;
    padding: 2rem;
    background: white;
    border-radius: 8px;
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
  }
  
  .loading-spinner {
    width: 32px;
    height: 32px;
    border: 3px solid #f3f3f3;
    border-top: 3px solid var(--primary-color);
    border-radius: 50%;
    animation: spin 1s linear infinite;
  }
  
  @keyframes spin {
    0% { transform: rotate(0deg); }
    100% { transform: rotate(360deg); }
  }
  
  /* Make sure field components don't break layout */
  .field-inline,
  .aifield-inline {
    white-space: nowrap;
    cursor: text;
  }
  
  /* Ensure text after fields inherits proper styling */
  .editor-content .field-inline + *,
  .editor-content .aifield-inline + * {
    color: inherit;
    background: inherit;
    font-family: inherit;
  }
  
  @media (max-width: 768px) {
    .editor-toolbar {
      flex-direction: column;
      align-items: flex-start;
    }
    
    .editor-actions {
      padding: 1rem;
      flex-direction: column;
      align-items: stretch;
      gap: 0.75rem;
    }
    
    .action-buttons {
      margin-left: 0;
      justify-content: stretch;
    }
    
    .action-buttons .btn {
      flex: 1;
    }
    
    .editor-content {
      padding: 1rem;
    }
  }
</style>
{% endblock %}

{% block content %}
<div class="container-fluid py-4">
  <div class="editor-container">
    <div class="editor-toolbar">
      <div class="editor-title">
        <i class="bi bi-pencil-square me-2"></i>Operative Note
      </div>
      <div class="editor-status">
        <span class="unsaved-indicator" id="unsavedIndicator" style="display: none;">
          <i class="bi bi-exclamation-circle me-1"></i>Unsaved changes
        </span>
        <span id="lastUpdated">...</span>
        <span class="status-badge" id="statusBadge">
          <i class="bi bi-file-text me-1"></i>
          <span id="statusText">Draft</span>
        </span>
      </div>
    </div>
    
    <div class="editor-actions">
      <div class="toolbar-group">
        <!-- Future toolbar buttons can go here -->
        
      </div>
      <div class="action-buttons">
        <button class="btn btn-sm btn-outline-primary" id="saveBtn">
          <i class="bi bi-save me-1"></i>Save
        </button>
      </div>
    </div>
    
    <div class="editor-main">
      <div 
        id="editorContent" 
        class="editor-content" 
        contenteditable="true"
        data-placeholder="Start typing your operative note, or select a template."
        spellcheck="false"
      ></div>
    </div>
  </div>
</div>
{% endblock %}

{% block scripts %}
<script>
// Field class to handle individual field behavior
class Field {
  constructor(element, editor) {
    this.element = element;
    this.editor = editor;
    this.fieldName = element.getAttribute('data-field-name');
    this.fieldType = element.getAttribute('data-field-type');
    this.isAI = element.classList.contains('aifield-inline');
    
    // Store bound event handlers for later removal
    this.boundHandlers = {
      focus: (e) => this.handleFocus(e),
      blur: (e) => this.handleBlur(e),
      keydown: (e) => this.handleKeydown(e),
      input: (e) => this.handleInput(e)
    };
    
    this.init();
  }
  
  init() {
    console.log('Initializing field:', this.fieldName, this.element);
    
    // Add mousedown event to ensure focus is maintained
    this.boundHandlers.mousedown = (e) => this.handleMousedown(e);
    
    // Bind events to this specific field element
    this.element.addEventListener('mousedown', this.boundHandlers.mousedown);
    this.element.addEventListener('focus', this.boundHandlers.focus);
    this.element.addEventListener('blur', this.boundHandlers.blur);
    this.element.addEventListener('keydown', this.boundHandlers.keydown);
    this.element.addEventListener('input', this.boundHandlers.input);
  }
  
  handleMousedown(e) {
    console.log('Field mousedown:', this.fieldName);
    // Stop event propagation to prevent main editor from interfering
    e.stopPropagation();
    // Ensure this field gets focus
    setTimeout(() => {
      this.element.focus();
    }, 10);
  }
  
  handleFocus(e) {
    console.log('Field focused (via', e.type === 'focus' ? 'event' : 'selection', '):', this.fieldName, 'activeElement:', document.activeElement);
    const text = this.element.textContent.trim();
    if (text === '***' || text === '{auto-generated field}') {
      // Select all text so user can immediately start typing
      setTimeout(() => {
        try {
          const range = document.createRange();
          range.selectNodeContents(this.element);
          const selection = window.getSelection();
          selection.removeAllRanges();
          selection.addRange(range);
        } catch (error) {
          console.error('Error selecting field content:', error);
        }
      }, 10);
    }
  }
  
  handleBlur(e) {
    console.log('Field blurred (via', e.type === 'blur' ? 'event' : 'selection', '):', this.fieldName, 'new activeElement:', document.activeElement, 'relatedTarget:', e.relatedTarget);
    setTimeout(() => {
      // Only restore placeholder if this field is not focused
      if (document.activeElement !== this.element && this.element.textContent.trim() === '') {
        if (this.isAI) {
          this.element.textContent = '{auto-generated field}';
        } else {
          this.element.textContent = '***';
        }
      }
    }, 10);
  }
  
  handleKeydown(e) {
    console.log('Key pressed in field:', e.key, this.fieldName);
    
    // Handle Enter key to insert line breaks within the field
    if (e.key === 'Enter') {
      e.preventDefault();
      e.stopPropagation();
      
      // Insert a <br> tag to create a new line within the field
      const selection = window.getSelection();
      if (selection.rangeCount > 0) {
        const range = selection.getRangeAt(0);
        range.deleteContents();
        const br = document.createElement('br');
        range.insertNode(br);
        range.setStartAfter(br);
        range.collapse(true);
        selection.removeAllRanges();
        selection.addRange(range);
      }
      return false;
    }
    
    // Prevent the field div from being deleted accidentally
    if (e.key === 'Backspace' && this.element.textContent.trim() === '') {
      e.preventDefault();
    }
  }
  
  handleInput(e) {
    console.log('Field input changed:', this.fieldName);
    this.editor.handleInput();
  }
  
  destroy() {
    // Clean up event listeners with the correct bound handlers
    this.element.removeEventListener('mousedown', this.boundHandlers.mousedown);
    this.element.removeEventListener('focus', this.boundHandlers.focus);
    this.element.removeEventListener('blur', this.boundHandlers.blur);
    this.element.removeEventListener('keydown', this.boundHandlers.keydown);
    this.element.removeEventListener('input', this.boundHandlers.input);
  }
}

class TextEditor {
  constructor(noteId = null) {
    this.noteId = noteId;
    this.editorContent = document.getElementById('editorContent');
    this.noteData = null;
    this.saveTimeout = null;
    this.lastSavedText = '';
    this.isModified = false;
    this.hasUnsavedChanges = false;
    this.fields = new Map(); // Track field instances
    this.currentField = null; // Track which field currently has cursor focus
    
    this.init();
  }
  
  init() {
    // Bind events
    this.editorContent.addEventListener('input', () => this.handleInput());
    this.editorContent.addEventListener('keydown', (e) => this.handleKeydown(e));
    this.editorContent.addEventListener('paste', (e) => this.handlePaste(e));
    
    // Prevent the main editor from stealing focus from fields
    this.editorContent.addEventListener('mousedown', (e) => {
      // If clicking on a field, don't let the main editor handle it
      if (e.target.classList.contains('field-inline') || e.target.classList.contains('aifield-inline')) {
        e.stopPropagation();
        return;
      }
    });
    
    // Monitor selection changes to detect when cursor moves into fields
    document.addEventListener('selectionchange', () => this.handleSelectionChange());
    
    // Save button
    document.getElementById('saveBtn').addEventListener('click', () => this.saveText());
    
    // Add placeholder functionality
    this.setupPlaceholder();
    
    // Load note data if noteId is provided
    if (this.noteId) {
      this.loadNote();
    } else {
      // Initial setup for new notes
      this.handleInput();
    }
  }
  
  handleSelectionChange() {
    const selection = window.getSelection();
    if (selection.rangeCount === 0) return;
    
    const range = selection.getRangeAt(0);
    let currentElement = range.startContainer;
    
    // Walk up the DOM tree to find if we're inside a field
    let fieldElement = null;
    while (currentElement && currentElement !== this.editorContent) {
      if (currentElement.nodeType === Node.ELEMENT_NODE && 
          (currentElement.classList.contains('field-inline') || currentElement.classList.contains('aifield-inline'))) {
        fieldElement = currentElement;
        break;
      }
      currentElement = currentElement.parentNode;
    }
    
    // Check if we've moved to a different field
    if (fieldElement !== this.currentField) {
      // Call blur on previous field if there was one
      if (this.currentField) {
        const prevFieldId = this.currentField.getAttribute('data-field-id');
        const prevField = this.fields.get(prevFieldId);
        if (prevField) {
          console.log('Selection moved out of field:', prevField.fieldName);
          // Create a synthetic blur event
          const blurEvent = new FocusEvent('blur', { bubbles: true });
          prevField.handleBlur(blurEvent);
        }
      }
      
      // Call focus on new field if there is one
      if (fieldElement) {
        const fieldId = fieldElement.getAttribute('data-field-id');
        const field = this.fields.get(fieldId);
        if (field) {
          console.log('Selection moved into field:', field.fieldName);
          // Create a synthetic focus event
          const focusEvent = new FocusEvent('focus', { bubbles: true });
          field.handleFocus(focusEvent);
        }
      }
      
      this.currentField = fieldElement;
    }
  }
  
  setupPlaceholder() {
    const placeholder = this.editorContent.getAttribute('data-placeholder');
    
    const updatePlaceholder = () => {
      if (this.editorContent.textContent.trim() === '' && this.editorContent.innerHTML.trim() === '') {
        this.editorContent.innerHTML = `<div style="color: #999; pointer-events: none; position: absolute;">${placeholder.replace(/\n/g, '<br>')}</div>`;
        this.editorContent.focus();
      }
    };
    
    this.editorContent.addEventListener('focus', () => {
      if (this.editorContent.querySelector('[style*="color: #999"]')) {
        this.editorContent.innerHTML = '';
      }
    });
    
    this.editorContent.addEventListener('blur', updatePlaceholder);
    
    // Initial placeholder
    if (this.editorContent.textContent.trim() === '') {
      updatePlaceholder();
    }
  }
  
  async loadNote() {
    try {
      this.showLoadingOverlay(true);
      
      const response = await fetch(`/api/v1/opnote/${this.noteId}/`);
      
      if (!response.ok) {
        if (response.status === 404) {
          showToast('Note not found', 'error');
          return;
        } else if (response.status === 401) {
          showToast('Authentication required', 'error');
          window.location.href = '/login';
          return;
        } else {
          throw new Error(`HTTP ${response.status}: ${response.statusText}`);
        }
      }
      
      const noteData = await response.json();
      this.noteData = noteData;
      
      // Load the text into the editor
      if (noteData.text) {
        this.renderTextWithFields(noteData.text);
        this.lastSavedText = noteData.text;
      } else {
        this.editorContent.innerHTML = '';
        this.lastSavedText = '';
      }
      
      // Reset modification state
      this.isModified = false;
      this.hasUnsavedChanges = false;
      this.updateUnsavedIndicator();
      
      // Update status badge
      this.updateStatusBadge(noteData.status);
      
      // Update last updated with better formatting
      const lastUpdated = noteData.updated_at ? 
        new Date(noteData.updated_at).toLocaleString('en-US', {
          year: 'numeric',
          month: 'short',
          day: 'numeric',
          hour: '2-digit',
          minute: '2-digit',
          hour12: true
        }) : 'Never';
      document.getElementById('lastUpdated').textContent = 'Last updated: ' + lastUpdated;
      
      // Update page title if we have a note title
      if (noteData.title) {
        document.title = `${noteData.title} - OperativeAI`;
        
        // Update the page header if there's a heading element
        const pageHeader = document.querySelector('.h3');
        if (pageHeader) {
          pageHeader.innerHTML = `<i class="bi bi-pencil-square me-2"></i>${noteData.title}`;
        }
      }
      
    } catch (error) {
      console.error('Error loading note:', error);
      showToast(`Error loading note: ${error.message}`, 'error');
    } finally {
      this.showLoadingOverlay(false);
    }
  }
  
  renderTextWithFields(text) {
    // Parse text and create HTML with inline contenteditable field divs
    let html = this.escapeHtml(text);
    
    // Replace field patterns with contenteditable divs
    const fieldPattern = /\[field:\s*([^\]]+)\]([\s\S]*?)\[\/field\]/g;
    const aifieldPattern = /\[aifield:\s*([^\]]+)\]([\s\S]*?)\[\/aifield\]/g;
    
    // Replace regular fields
    html = html.replace(fieldPattern, (match, fieldName, content) => {
      const fieldId = this.generateFieldId();
      const escapedContent = content.trim() === '' ? '***' : content;
      const placeholder = `Enter ${fieldName.trim()}`;
      
      return `<span tabindex="0" class="field-inline" contenteditable="true" data-field-name="${this.escapeHtml(fieldName.trim())}" data-field-type="field" data-field-id="${fieldId}" data-placeholder="${placeholder}">${escapedContent}</span>`;
    });
    
    // Replace AI fields
    html = html.replace(aifieldPattern, (match, fieldName, content) => {
      const fieldId = this.generateFieldId();
      const escapedContent = content.trim() === '' ? '{auto-generated field}' : content;
      const placeholder = `Enter ${fieldName.trim()}`;
      
      return `<span tabindex="0" class="aifield-inline" contenteditable="true" data-field-name="${this.escapeHtml(fieldName.trim())}" data-field-type="aifield" data-field-id="${fieldId}" data-placeholder="${placeholder}">${escapedContent}</span>`;
    });
    
    // Convert newlines to br tags for proper display
    html = html.replace(/\n/g, '<br>');
    
    this.editorContent.innerHTML = html;
    
    console.log('Content rendered, initializing fields now');
    
    // Initialize field instances
    this.initializeFields();
  }
  
  initializeFields() {
    // Clean up existing field instances
    this.fields.forEach(field => field.destroy());
    this.fields.clear();
    this.currentField = null; // Reset current field tracking
    
    // Find all field elements and create Field instances
    const fieldElements = this.editorContent.querySelectorAll('.field-inline, .aifield-inline');
    console.log('Found', fieldElements.length, 'field elements');
    
    fieldElements.forEach((element, index) => {
      console.log(`Field ${index}:`, element);
      console.log('  - classList:', element.classList.toString());
      console.log('  - data-field-name:', element.getAttribute('data-field-name'));
      console.log('  - data-field-id:', element.getAttribute('data-field-id'));
      console.log('  - contenteditable:', element.getAttribute('contenteditable'));
      console.log('  - textContent:', element.textContent);
      
      const fieldId = element.getAttribute('data-field-id');
      if (fieldId) {
        const field = new Field(element, this);
        this.fields.set(fieldId, field);
      } else {
        console.warn('Field element missing data-field-id:', element);
      }
    });
    
    console.log('Initialized', this.fields.size, 'field instances');
  }
  
  generateFieldId() {
    return 'field_' + Math.random().toString(36).substr(2, 9);
  }
  
  updateUnsavedIndicator() {
    const unsavedIndicator = document.getElementById('unsavedIndicator');
    if (unsavedIndicator) {
      unsavedIndicator.style.display = this.hasUnsavedChanges ? 'inline-block' : 'none';
    }
  }
  
  updateStatusBadge(status) {
    const statusBadge = document.getElementById('statusBadge');
    const statusText = document.getElementById('statusText');
    
    if (!statusBadge || !statusText) return;
    
    // Remove existing status classes
    statusBadge.classList.remove('draft', 'optimized', 'signed');
    
    // Update status text and styling based on status
    switch(status) {
      case 'draft':
        statusText.textContent = 'Draft';
        statusBadge.classList.add('draft');
        statusBadge.querySelector('i').className = 'bi bi-file-text me-1';
        break;
      case 'optimized':
        statusText.textContent = 'Validated & Coded';
        statusBadge.classList.add('optimized');
        statusBadge.querySelector('i').className = 'bi bi-magic me-1';
        break;
      case 'signed':
        statusText.textContent = 'Finalized';
        statusBadge.classList.add('signed');
        statusBadge.querySelector('i').className = 'bi bi-check-circle me-1';
        break;
      default:
        statusText.textContent = 'Unknown';
        statusBadge.classList.add('draft');
        statusBadge.querySelector('i').className = 'bi bi-question-circle me-1';
    }
  }
  
  showLoadingOverlay(show) {
    if (show) {
      // Gray out the editor content
      this.editorContent.style.opacity = '0.5';
      this.editorContent.style.pointerEvents = 'none';
      
      // Create and show loading overlay
      if (!this.loadingOverlay) {
        this.loadingOverlay = document.createElement('div');
        this.loadingOverlay.className = 'editor-loading-overlay';
        this.loadingOverlay.innerHTML = `
          <div class="loading-content">
            <div class="loading-spinner"></div>
            <div>Loading note...</div>
          </div>
        `;
        this.editorContent.parentElement.style.position = 'relative';
        this.editorContent.parentElement.appendChild(this.loadingOverlay);
      }
      this.loadingOverlay.style.display = 'flex';
    } else {
      // Restore editor content
      this.editorContent.style.opacity = '1';
      this.editorContent.style.pointerEvents = 'auto';
      
      // Hide loading overlay
      if (this.loadingOverlay) {
        this.loadingOverlay.style.display = 'none';
      }
    }
  }
  
  handleInput() {
    // Check if content has been modified
    const currentText = this.reconstructTextFromHTML();
    this.isModified = currentText !== this.lastSavedText;
    this.hasUnsavedChanges = this.isModified;
    
    // Show/hide unsaved indicator
    this.updateUnsavedIndicator();
    
    // Auto-save after 2 seconds of inactivity (only for existing notes)
    if (this.noteId && this.isModified) {
      if (this.saveTimeout) {
        clearTimeout(this.saveTimeout);
      }
      this.saveTimeout = setTimeout(() => {
        this.autoSave();
      }, 2000);
    }
  }
  
  handleKeydown(e) {
    // Handle tab key for indentation
    if (e.key === 'Tab') {
      e.preventDefault();
      document.execCommand('insertText', false, '  ');
    }
    
    // Prevent deletion of field containers
    if (e.key === 'Backspace' || e.key === 'Delete') {
      const selection = window.getSelection();
      if (selection.rangeCount > 0) {
        const range = selection.getRangeAt(0);
        const field = range.startContainer.closest?.('.field-inline, .aifield-inline') || 
                     range.startContainer.parentElement?.closest?.('.field-inline, .aifield-inline');
        
        if (field && field.textContent === '' && e.key === 'Backspace') {
          e.preventDefault();
        }
      }
    }
  }
  
  handlePaste(e) {
    e.preventDefault();
    const text = e.clipboardData.getData('text/plain');
    document.execCommand('insertText', false, text);
  }
  
  reconstructTextFromHTML() {
    // Walk through the HTML and reconstruct the original text format
    let result = '';
    
    const traverse = (node) => {
      if (node.nodeType === Node.TEXT_NODE) {
        result += node.textContent;
      } else if (node.nodeType === Node.ELEMENT_NODE) {
        if (node.classList.contains('field-inline')) {
          const fieldName = node.getAttribute('data-field-name');
          // Get the text content directly since there are no child elements now
          let content = node.textContent.replace(/^\s*|\s*$/g, ''); // trim whitespace
          // Convert *** back to empty content for saving
          if (content === '***') {
            content = '';
          }
          result += `[field: ${fieldName}]${content}[/field]`;
        } else if (node.classList.contains('aifield-inline')) {
          const fieldName = node.getAttribute('data-field-name');
          // Get the text content directly since there are no child elements now
          let content = node.textContent.replace(/^\s*|\s*$/g, ''); // trim whitespace
          // Convert *** back to empty content for saving
          if (content === '***' || content === '{auto-generated field}') {
            content = '';
          }
          result += `[aifield: ${fieldName}]${content}[/aifield]`;
        } else if (node.tagName === 'BR') {
          result += '\n';
        } else {
          // Traverse child nodes
          for (let child of node.childNodes) {
            traverse(child);
          }
        }
      }
    };
    
    traverse(this.editorContent);
    
    return result;
  }
  
  escapeHtml(text) {
    const div = document.createElement('div');
    div.textContent = text;
    return div.innerHTML;
  }
  
  async autoSave() {
    if (!this.noteId || !this.isModified) return;
    
    const text = this.reconstructTextFromHTML();
    
    try {
      const response = await fetch(`/api/v1/opnote/${this.noteId}/`, {
        method: 'PUT',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          text: text
        })
      });
      
      if (response.ok) {
        this.lastSavedText = text;
        this.isModified = false;
        this.hasUnsavedChanges = false;
        this.updateUnsavedIndicator();
        
        // Show subtle auto-save indicator
        const statusEl = document.querySelector('.editor-status');
        const originalContent = statusEl.innerHTML;
        statusEl.innerHTML = '<span style="color: #28a745;">Auto-saved</span>';
        setTimeout(() => {
          statusEl.innerHTML = originalContent;
        }, 2000);
      }
    } catch (error) {
      console.error('Auto-save failed:', error);
    }
  }
  
  saveText() {
    const text = this.reconstructTextFromHTML();
    
    if (this.noteId && this.noteData) {
      // Save to API
      this.saveToAPI(text);
    }
  }
  
  async saveToAPI(text) {
    try {      
      const response = await fetch(`/api/v1/opnote/${this.noteId}/`, {
        method: 'PUT',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          text: text
        })
      });
      
      if (!response.ok) {
        if (response.status === 401) {
          showToast('Authentication required', 'error');
          window.location.href = '/login';
          return;
        } else {
          const errorData = await response.json().catch(() => ({}));
          throw new Error(errorData.message || `HTTP ${response.status}: ${response.statusText}`);
        }
      }
      
      const updatedNote = await response.json();
      this.noteData = updatedNote;
      this.lastSavedText = text;
      this.isModified = false;
      this.hasUnsavedChanges = false;
      this.updateUnsavedIndicator();
      
      // Update status badge if status changed
      this.updateStatusBadge(updatedNote.status);
      
      // Update last updated time with better formatting
      const lastUpdated = new Date(updatedNote.updated_at).toLocaleString('en-US', {
        year: 'numeric',
        month: 'short',
        day: 'numeric',
        hour: '2-digit',
        minute: '2-digit',
        hour12: true
      });
      document.getElementById('lastUpdated').textContent = 'Last updated: ' + lastUpdated;
      
      showToast('Note saved successfully', 'success');
      
    } catch (error) {
      console.error('Error saving note:', error);
      showToast(`Error saving note: ${error.message}`, 'error');
    }
  }
}

// Initialize editor when DOM is ready
document.addEventListener('DOMContentLoaded', function() {
  // Get note_id from the template context (passed during server-side rendering)
  const noteId = {{ note_id | tojson if note_id else 'null' }};
  
  const editor = new TextEditor(noteId);
  console.log('Text editor initialized', noteId ? `with note_id: ${noteId}` : 'for new note');
});
</script>
{% endblock %}